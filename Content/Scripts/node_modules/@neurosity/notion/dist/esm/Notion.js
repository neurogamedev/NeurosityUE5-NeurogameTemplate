var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Observable, BehaviorSubject, throwError, of, empty, from } from "rxjs";
import { map, share, switchMap } from "rxjs/operators";
import { ApiClient, credentialWithLink, createUser, SERVER_TIMESTAMP } from "./api/index";
import { whileOnline } from "./utils/whileOnline";
import { getLabels, validate, isNotionMetric } from "./utils/subscription";
import * as errors from "./utils/errors";
const defaultOptions = {
    timesync: false,
    autoSelectDevice: true
};
/**
 * Example
 * ```typescript
 * import { Notion } from "@neurosity/notion";
 *
 * const notion = new Notion();
 * ```
 */
export class Notion {
    /**
     * Creates new instance of Notion
     *
     * ```typescript
     * const notion = new Notion();
     * ```
  
     * @param options
     */
    constructor(options = {}) {
        /**
         * @internal
         */
        this._localModeSubject = new BehaviorSubject(false);
        /**
         * @internal
         * Not user facing
         */
        this.getMetric = (subscription) => {
            const { metric, labels, atomic } = subscription;
            const error = validate(metric, labels, this.options);
            if (error) {
                return throwError(error);
            }
            const subscribeTo = (serverType) => new Observable((observer) => {
                const subscriptions = atomic
                    ? [
                        this.api.metrics.subscribe({
                            metric: metric,
                            labels: labels,
                            atomic: atomic,
                            serverType: serverType
                        })
                    ]
                    : labels.map((label) => {
                        return this.api.metrics.subscribe({
                            metric: metric,
                            labels: [label],
                            atomic: atomic,
                            serverType: serverType
                        });
                    });
                const subscriptionWithListeners = subscriptions.map((subscription) => ({
                    subscription,
                    listener: this.api.metrics.on(subscription, (...data) => {
                        observer.next(...data);
                    })
                }));
                return () => {
                    subscriptionWithListeners.forEach(({ subscription, listener }) => {
                        this.api.metrics.unsubscribe(subscription, listener);
                    });
                };
            });
            return this.onDeviceChange().pipe(switchMap((device) => {
                if (!device) {
                    return empty();
                }
                const { deviceId } = device;
                return this.isLocalMode().pipe(switchMap((isLocalMode) => {
                    if (isLocalMode && isNotionMetric(metric)) {
                        return this.socketUrl().pipe(switchMap((socketUrl) => this.api.setWebsocket(socketUrl, deviceId)), switchMap(() => subscribeTo(this.api.localServerType)));
                    }
                    this.api.unsetWebsocket();
                    return subscribeTo(this.api.defaultServerType);
                }));
            }), whileOnline({
                status$: this.status(),
                allowWhileOnSleepMode: false
            }));
        };
        this.options = Object.freeze(Object.assign(Object.assign({}, defaultOptions), options));
        this.api = new ApiClient(this.options);
    }
    /**
     * Starts user session
     *
     * ```typescript
     * await notion.login({
     *   email: "...",
     *   password: "..."
     * });
     * ```
     *
     * @param credentials
     */
    login(credentials) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.api.login(credentials);
        });
    }
    /**
     * Ends user session
     *
     * ```typescript
     * await notion.logout();
     * // session has ended
     * ```
     *
     */
    logout() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.api.logout();
        });
    }
    /**
     * @internal
     * Not user facing.
     */
    __getApp() {
        return this.api.__getApp();
    }
    /**
     * @internal
     * Not user facing yet
     */
    onAuthStateChanged() {
        return this.api.onAuthStateChanged();
    }
    /**
     * @internal
     * Not user facing yet
     */
    addDevice(deviceId) {
        return this.api.addDevice(deviceId);
    }
    /**
     * @internal
     * Not user facing yet
     */
    removeDevice(deviceId) {
        return this.api.removeDevice(deviceId);
    }
    /**
     * @internal
     * Not user facing yet
     */
    onUserDevicesChange() {
        return this.api.onUserDevicesChange();
    }
    /**
     * Get user devices
     *
     * Returns a list of devices claimed by the user authenticated.
     *
     * ```typescript
     * const devices = await notion.getDevices();
     * console.log(devices);
     * ```
     */
    getDevices() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.api.getDevices();
        });
    }
    /**
     * Select Device
     *
     * Rarely necessary, but useful when the user owns multiple devices.
     *
     * A common use case for manually selecting a device is when you wish to build a device dropdown a user can select from, instead of collecting the Device Id from the user ahead of time.
     *
     * The 3 steps to manually selecting a device are:
     *
     * - Set `autoSelectDevice` to false when instantiating `Notion`.
     * - Authenticate with your Neurosity account to access your devices by calling the `notion.login(...)` function.
     * - Call the `notion.selectDevice(...)` function with a device selector function.
     *
     * ```typescript
     * const devices = await notion.selectDevice((devices) =>
     *   devices.find((device) => device.deviceNickname === "Notion-A1B")
     * );
     *
     * console.log(devices);
     * ```
     *
     * > If you own multiple devices, and don't pass `autoSelectDevice`, then the first device on the list will be automatically selected.
     *
     * For more info, check out the "Device Selection" guide.
     */
    selectDevice(deviceSelector) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.api.selectDevice(deviceSelector);
        });
    }
    /**
     * Get selected device
     *
     * ```typescript
     * const selectedDevice = await notion.getSelectedDevice();
     * console.log(selectedDevice);
     * ```
     */
    getSelectedDevice() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.api.getSelectedDevice();
        });
    }
    /**
     * ```typescript
     * const info = await notion.getInfo();
     * ```
     */
    getInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.api.didSelectDevice()) {
                return Promise.reject(errors.mustSelectDevice);
            }
            return yield this.api.getInfo();
        });
    }
    /**
     * Observes Local Mode changes
     *
     * ```typescript
     * notion.isLocalMode().subscribe(isLocalMode => {
     *  console.log(isLocalMode);
     * });
     * ```
     */
    isLocalMode() {
        return this._localModeSubject.asObservable().pipe(share());
    }
    /**
     * Observes selected device
     *
     * ```typescript
     * notion.onDeviceChange().subscribe(device => {
     *  console.log(device);
     * });
     * ```
     */
    onDeviceChange() {
        return this.api.onDeviceChange();
    }
    /**
     * Enables/disables local mode
     *
     * With local mode, device metrics like brainwaves, calm, focus, etc will stream
     * via your local WiFi network and not the default cloud server.
     *
     * Local Mode is disabled by default, to enable it:
     *
     * ```typescript
     * await notion.enableLocalMode(true);
     * ```
     *
     * To disable it:
     *
     * ```typescript
     * await notion.enableLocalMode(false);
     * ```
     *
     * Keep in mind:
     *  - Activity Logging will <em>not work</em> while this setting is enabled.
     *  - Your Notion must be connected to the same WiFi network as this device to establish communication.
     *  - An internet connection is still needed to authenticate, get device status and add metric subscriptions.
     *  - This setting is not global and needs to be set for every Notion app you wish to affect.
     */
    enableLocalMode(shouldEnable) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof shouldEnable !== "boolean") {
                return Promise.reject(new TypeError("enableLocalMode can only accept a boolean"));
            }
            if (!shouldEnable) {
                this._localModeSubject.next(shouldEnable);
                return shouldEnable;
            }
            const [localModeSupported, error] = yield this.api
                .onceNamespace("context/socketUrl")
                .then((socketUrl) => {
                if (!socketUrl) {
                    const error = `Your device's OS does not support localMode. Try updating to the latest OS.`;
                    return [false, new Error(error)];
                }
                return [true, null];
            })
                .catch((error) => [false, error]);
            if (!localModeSupported) {
                return Promise.reject(error);
            }
            this._localModeSubject.next(shouldEnable);
            return shouldEnable;
        });
    }
    /**
     * Ends database connection
     *
     * ```typescript
     * await notion.disconnect();
     * ```
     */
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.api.disconnect();
        });
    }
    /**
     * @internal
     * Not user facing
     */
    socketUrl() {
        const { onDeviceSocketUrl } = this.options;
        if (onDeviceSocketUrl) {
            return of(onDeviceSocketUrl);
        }
        return this.api.observeNamespace("context/socketUrl");
    }
    /**
     * @internal
     * Not user facing
     */
    dispatchAction(action) {
        if (!this.api.didSelectDevice()) {
            return Promise.reject(errors.mustSelectDevice);
        }
        return this.api.actions.dispatch(action);
    }
    /**
     * Injects an EEG marker to data stream
     *
     * ```typescript
     * notion.addMarker("eyes-closed");
     *
     * // later...
     *
     * notion.addMarker("eyes-open");
     * ```
     *
     * @param label Name the label to inject
     */
    addMarker(label) {
        if (!this.api.didSelectDevice()) {
            throw errors.mustSelectDevice;
        }
        if (!label) {
            throw new Error("Notion: a label is required for addMarker");
        }
        this.dispatchAction({
            command: "marker",
            action: "add",
            message: {
                label,
                timestamp: this.api.timestamp
            }
        });
    }
    /**
     * Observes accelerometer data
     * Supported by Notion 2 and the Crown.
     *
     * ```typescript
     * notion.accelerometer().subscribe(accelerometer => {
     *   console.log(accelerometer);
     * });
     *
     * // { acceleration: ..., inclination: ..., orientation: ..., pitch: ..., roll: ..., x: ..., y: ..., z: ... }
     * ```
     *
     * @returns Observable of accelerometer metric events
     */
    accelerometer() {
        const metric = "accelerometer";
        return from(this.getSelectedDevice()).pipe(switchMap((selectedDevice) => {
            const modelVersionWithAccelSupport = 2;
            const isModelVersion2OrGreater = Number(selectedDevice === null || selectedDevice === void 0 ? void 0 : selectedDevice.modelVersion) >=
                modelVersionWithAccelSupport;
            if (!isModelVersion2OrGreater) {
                return throwError(new Error(`The ${metric} metric is not supported by this device. Model version ${modelVersionWithAccelSupport} or greater required.`));
            }
            return this.getMetric({
                metric,
                labels: getLabels(metric),
                atomic: true
            });
        }));
    }
    /**
     * @internal
     *
     * @param labels Name of metric properties to filter by
     * @returns Observable of awareness metric events
     */
    awareness(label, ...otherLabels) {
        return this.getMetric({
            metric: "awareness",
            labels: label ? [label, ...otherLabels] : [],
            atomic: false
        });
    }
    /**
     * The `raw` brainwaves parameter emits epochs of 25 samples.
     *
     * Example
     * ```typescript
     * notion.brainwaves("raw").subscribe(brainwaves => {
     *   console.log(brainwaves);
     * });
     * ```
     *
     * Raw Unfiltered - The `rawUnfiltered` brainwaves parameter emits epochs of 25 samples.
  
     * Example
     * ```typescript
     * notion.brainwaves("rawUnfiltered").subscribe(brainwaves => {
     *   console.log(brainwaves);
     * });
     * ```
     *
     * Power By Band - The `powerByBand` brainwaves parameter emits epochs 4 times a second. Every frequency label (e.g. beta) contains an average power value per channel.
     *
     * Example
     * ```typescript
     * notion.brainwaves("powerByBand").subscribe(brainwaves => {
     *   console.log(brainwaves);
     * });
     * ```
     *
     * Power Spectral Density (PSD) - The `psd` brainwaves parameter emits epochs 4 times a second. Every frequency label (e.g. alpha) contains the computed FFT (Fast Fourier transform) value per channel (see the `psd` property), as well as the frequency ranges (see the `freqs` property).
     *
     * Example
     * ```typescript
     * notion.brainwaves("psd").subscribe(brainwaves => {
     *   console.log(brainwaves);
     * });
     * ```
     *
     * @param labels Name of metric properties to filter by
     * @returns Observable of brainwaves metric events
     */
    brainwaves(label, ...otherLabels) {
        return this.getMetric({
            metric: "brainwaves",
            labels: label ? [label, ...otherLabels] : [],
            atomic: false
        });
    }
    /**
     * Example
     * ```typescript
     * notion.calm().subscribe(calm => {
     *   console.log(calm.probability);
     * });
     *
     * // 0.45
     * // 0.47
     * // 0.53
     * // 0.51
     * // ...
     * ```
     *
     * @returns Observable of calm events - awareness/calm alias
     */
    calm() {
        return this.awareness("calm");
    }
    /**
     * Observes signal quality data where each property is the name
     * of the channel and the value includes the standard deviation and
     * a status set by the device
     *
     * ```typescript
     * notion.signalQuality().subscribe(signalQuality => {
     *   console.log(signalQuality);
     * });
     *
     * // { FC6: { standardDeviation: 3.5, status: "good" }, C3: {...}, ... }
     * ```
     *
     * @returns Observable of signalQuality metric events
     */
    signalQuality() {
        const metric = "signalQuality";
        return this.getMetric({
            metric,
            labels: getLabels(metric),
            atomic: true
        });
    }
    /**
     * @internal
     * Proof of Concept for `emotion` - Not user facing yet
     *
     * @returns Observable of emotion metric events
     */
    emotion(label, ...otherLabels) {
        return this.getMetric({
            metric: "emotion",
            labels: label ? [label, ...otherLabels] : [],
            atomic: false
        });
    }
    /**
     * Observes last state of `settings` and all subsequent `settings` changes
     *
     * ```typescript
     * notion.settings().subscribe(settings => {
     *   console.log(settings.lsl);
     * });
     *
     * // true
     * // ...
     * ```
     *
     * @returns Observable of `settings` metric events
     */
    settings() {
        return this.api.observeNamespace("settings");
    }
    /**
     * Example
     * ```typescript
     * notion.focus().subscribe(focus => {
     *   console.log(focus.probability);
     * });
     *
     * // 0.56
     * // 0.46
     * // 0.31
     * // 0.39
     * // ...
     * ```
     *
     * @returns Observable of focus events - awareness/focus alias
     */
    focus() {
        return this.awareness("focus");
    }
    /**
     * @param labels Name of metric properties to filter by
     * @returns Observable of kinesis metric events
     */
    kinesis(label, ...otherLabels) {
        return this.getMetric({
            metric: "kinesis",
            labels: label ? [label, ...otherLabels] : [],
            atomic: false
        });
    }
    /**
     * @param labels Name of metric properties to filter by
     * @returns Observable of predictions metric events
     */
    predictions(label, ...otherLabels) {
        return this.getMetric({
            metric: "predictions",
            labels: label ? [label, ...otherLabels] : [],
            atomic: false
        });
    }
    /**
     * Observes last state of `status` and all subsequent `status` changes
     *
     * ```typescript
     * notion.status().subscribe(status => {
     *   console.log(status.state);
     * });
     *
     * // "online"
     * // ...
     * ```
     *
     * @returns Observable of `status` metric events
     */
    status() {
        return this.api.status();
    }
    /**
     * @internal
     * Not user facing yet
     *
     * Changes device settings programmatically. These settings can be
     * also changed from the developer console under device settings.
     *
     * Available settings [[ChangeSettings]]
     *
     * Example
     * ```typescript
     * notion.changeSettings({
     *   lsl: true
     * });
     * ```
     */
    changeSettings(settings) {
        if (!this.api.didSelectDevice()) {
            return Promise.reject(errors.mustSelectDevice);
        }
        return this.api.changeSettings(settings);
    }
    /**
     *
     * ```typescript
     * notion.training.record({
     *   metric: "kinesis",
     *   label: "push"
     * });
     *
     * notion.training.stop({
     *   metric: "kinesis",
     *   label: "push"
     * });
     * ```
     *
     * @returns Training methods
     */
    get training() {
        return {
            /**
             * Records a training for a metric/label pair
             * @category Training
             */
            record: (training) => {
                if (!this.api.didSelectDevice()) {
                    throw errors.mustSelectDevice;
                }
                const userId = this.api.user && "uid" in this.api.user
                    ? this.api.user.uid
                    : null;
                const message = Object.assign(Object.assign({ fit: false, baseline: false, timestamp: this.api.timestamp }, training), { userId });
                this.api.actions.dispatch({
                    command: "training",
                    action: "record",
                    message
                });
            },
            /**
             * Stops the training for a metric/label pair
             * @category Training
             */
            stop: (training) => {
                if (!this.api.didSelectDevice()) {
                    throw errors.mustSelectDevice;
                }
                this.api.actions.dispatch({
                    command: "training",
                    action: "stop",
                    message: Object.assign({}, training)
                });
            },
            /**
             * Stops all trainings
             * @category Training
             */
            stopAll: () => {
                if (!this.api.didSelectDevice()) {
                    throw errors.mustSelectDevice;
                }
                this.api.actions.dispatch({
                    command: "training",
                    action: "stopAll",
                    message: {}
                });
            }
        };
    }
    /**
     * @internal
     * Proof of Concept for disconnecting db
     */
    goOffline() {
        this.api.goOffline();
    }
    /**
     * @internal
     * Proof of Concept for resuming db connection
     */
    goOnline() {
        this.api.goOnline();
    }
    /**
     * @internal
     * Not user facing yet
     *
     * Creates user account and automatically signs in with same credentials
     *
     * @param emailAndPasswordObject
     * @returns user credential
     */
    createAccount(credentials) {
        return this.api.createAccount(credentials);
    }
    /**
     * @internal
     * Not user facing yet
     *
     * Removes all devices from an account and then deletes the account
     */
    deleteAccount() {
        return this.api.deleteAccount();
    }
    /**
     * @internal
     * Not user facing yet
     *
     * Creates custom token (JWT) to use to login with `{ customToken }`.
     *
     * @returns custom token
     */
    createCustomToken() {
        return this.api.createCustomToken();
    }
    /**
     * @internal
     * Not user facing yet
     *
     * Gets the offset between the device's clock and the client's clock
     * Requires option.timesync to be true
     *
     * @returns timesyncOffset
     */
    getTimesyncOffset() {
        if (!this.options.timesync) {
            console.warn(`getTimesyncOffset() requires options.timesync to be true.`);
        }
        return this.options.timesync ? this.api.getTimesyncOffset() : 0;
    }
    /**
     * @internal
     * Proof of Concept for Skills - Not user facing yet
     *
     * Accesses a skill by Bundle ID. Additionally, allows to observe
     * and push skill metrics
     *
     * @param bundleId Bundle ID of skill
     * @returns Skill instance
     */
    skill(bundleId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.api.didSelectDevice()) {
                return Promise.reject(errors.mustSelectDevice);
            }
            const skillData = yield this.api.skills.get(bundleId);
            if (skillData === null) {
                return Promise.reject(new Error(`Access denied for: ${bundleId}. Make sure the skill is installed.`));
            }
            return {
                metric: (label) => {
                    const metricName = `skill~${skillData.id}~${label}`;
                    const subscription = new Observable((observer) => {
                        const subscription = this.api.metrics.subscribe({
                            metric: metricName,
                            labels: [label],
                            atomic: true
                        });
                        const listener = this.api.metrics.on(subscription, (...data) => {
                            observer.next(...data);
                        });
                        return () => {
                            this.api.metrics.unsubscribe(subscription, listener);
                        };
                    }).pipe(map((metric) => metric[label]));
                    Object.defineProperty(subscription, "next", {
                        value: (metricValue) => {
                            this.api.metrics.next(metricName, {
                                [label]: metricValue
                            });
                        }
                    });
                    return subscription;
                }
            };
        });
    }
}
/**
 *
 * @hidden
 */
Notion.credentialWithLink = credentialWithLink;
/**
 *
 * @hidden
 */
Notion.createUser = createUser;
/**
 *
 * @hidden
 */
Notion.SERVER_TIMESTAMP = SERVER_TIMESTAMP;
