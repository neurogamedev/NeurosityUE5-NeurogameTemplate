{"version":3,"sources":["api/firebase/config.ts","api/firebase/FirebaseApp.ts","api/firebase/FirebaseUser.ts","api/firebase/deviceStore.ts","api/firebase/FirebaseDevice.ts","api/firebase/index.ts","api/websocket/index.ts","utils/whileOnline.ts","timesync/Timesync.ts","timesync/index.ts","subscriptions/SubscriptionManager.ts","api/index.ts","utils/subscription.ts","utils/errors.ts","Notion.ts","skills/NotionOnDevice.ts","skills/createSkill.ts","skills/index.ts","index.ts"],"names":[],"mappings":"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","file":"index.js","sourceRoot":"../../src","sourcesContent":["export const config = {\n  apiKey: \"AIzaSyB0TkZ83Fj0CIzn8AAmE-Osc92s3ER8hy8\",\n  authDomain: \"neurosity-device.firebaseapp.com\",\n  databaseURL: \"https://neurosity-device.firebaseio.com\",\n  projectId: \"neurosity-device\",\n  storageBucket: \"neurosity-device.appspot.com\",\n  messagingSenderId: \"212595049674\"\n};\n","import firebase from \"firebase/app\";\nimport \"firebase/database\";\nimport \"firebase/auth\";\nimport \"firebase/functions\";\nimport \"firebase/firestore\";\n\nimport { config } from \"./config\";\nimport { NotionOptions } from \"../../types/options\";\n\nexport const SERVER_TIMESTAMP = firebase.database.ServerValue.TIMESTAMP;\n\n/**\n * @hidden\n */\nexport class FirebaseApp {\n  protected standalone: boolean;\n  public app: firebase.app.App;\n\n  constructor(options: NotionOptions) {\n    this.app = this.getApp(options.deviceId);\n    this.standalone = this.app.name === options.deviceId;\n  }\n\n  private getApp(deviceId?: string) {\n    const moduleApps = firebase.apps;\n    const browserApps =\n      typeof window !== \"undefined\" &&\n      \"firebase\" in window &&\n      \"apps\" in window.firebase\n        ? window.firebase.apps\n        : [];\n\n    const neurosityApp = [...moduleApps, ...browserApps].find(\n      (app: any) =>\n        app.name === \"[DEFAULT]\" &&\n        app.options.databaseURL === config.databaseURL\n    );\n\n    if (neurosityApp) {\n      return neurosityApp;\n    }\n\n    if (deviceId) {\n      const notionAppName = deviceId;\n      const notionApp = moduleApps.find(\n        (app) => app.name === notionAppName\n      );\n      return notionApp\n        ? notionApp\n        : firebase.initializeApp(config, notionAppName);\n    }\n\n    return firebase.initializeApp(config);\n  }\n\n  goOnline() {\n    this.app.database().goOnline();\n  }\n\n  goOffline() {\n    this.app.database().goOffline();\n  }\n\n  public disconnect(): Promise<any> {\n    if (this.standalone) {\n      return this.app.delete();\n    }\n    return Promise.resolve();\n  }\n}\n","import { Observable, fromEventPattern, from, empty } from \"rxjs\";\nimport { map, switchMap } from \"rxjs/operators\";\nimport firebase from \"firebase/app\";\nimport { User } from \"@firebase/auth-types\";\n\nimport { FirebaseApp } from \"./FirebaseApp\";\nimport {\n  Credentials,\n  EmailAndPassword,\n  CustomToken\n} from \"../../types/credentials\";\nimport { UserDevices } from \"../../types/user\";\nimport { DeviceInfo } from \"../../types/deviceInfo\";\n\nconst SERVER_TIMESTAMP = firebase.database.ServerValue.TIMESTAMP;\n\n/**\n * @hidden\n */\nexport const credentialWithLink: Function =\n  firebase.auth.EmailAuthProvider.credentialWithLink;\n\n/**\n * @hidden\n */\nexport function createUser(...args) {\n  return new (firebase as any).User(...args);\n}\n\n/**\n * @hidden\n */\nexport class FirebaseUser {\n  public app: firebase.app.App;\n  public user: User | null;\n\n  constructor(firebaseApp: FirebaseApp) {\n    this.app = firebaseApp.app;\n\n    this.app.auth().onAuthStateChanged((user: User | null) => {\n      this.user = user;\n    });\n  }\n\n  public auth() {\n    return this.app.auth();\n  }\n\n  async createAccount(credentials: EmailAndPassword) {\n    const { email, password } = credentials;\n    const [error, user] = await this.app\n      .auth()\n      .createUserWithEmailAndPassword(email, password)\n      .then((user) => [null, user])\n      .catch((error) => [error, null]);\n\n    if (error) {\n      return Promise.reject(error);\n    }\n\n    return user;\n  }\n\n  async deleteAccount() {\n    const user = this.app.auth().currentUser;\n\n    if (!user) {\n      return Promise.reject(\n        new Error(\n          `You are trying to delete an account that is not authenticated. To delete an account, the account must have signed in recently.`\n        )\n      );\n    }\n\n    const [devicesError, devices] = await this.getDevices()\n      .then((response) => [null, response])\n      .catch((error) => [error, null]);\n\n    if (devicesError) {\n      return Promise.reject(devicesError);\n    }\n\n    if (devices.length) {\n      const removeDeviceError = await Promise.all(\n        devices.map((device) => this.removeDevice(device.deviceId))\n      )\n        .then(() => null)\n        .catch((error) => error);\n\n      if (removeDeviceError) {\n        return Promise.reject(removeDeviceError);\n      }\n    }\n\n    return user.delete();\n  }\n\n  onAuthStateChanged(): Observable<User | null> {\n    return new Observable((subscriber) => {\n      try {\n        this.app.auth().onAuthStateChanged(\n          (user: User | null) => {\n            subscriber.next(user);\n          },\n          (error) => {\n            subscriber.error(error);\n          }\n        );\n      } catch (error) {\n        subscriber.error(error);\n      }\n    });\n  }\n\n  onLogin(): Observable<User> {\n    return new Observable((subscriber) => {\n      const unsubscribe = this.app\n        .auth()\n        .onAuthStateChanged((user: User) => {\n          if (!!user) {\n            subscriber.next(user);\n            subscriber.complete();\n          }\n        });\n      return () => unsubscribe();\n    });\n  }\n\n  login(credentials: Credentials) {\n    if (\"customToken\" in credentials) {\n      const { customToken } = credentials;\n      return this.app.auth().signInWithCustomToken(customToken);\n    }\n\n    if (\"idToken\" in credentials && \"providerId\" in credentials) {\n      const provider = new firebase.auth.OAuthProvider(\n        credentials.providerId\n      );\n      const oAuthCredential = provider.credential(credentials.idToken);\n      return this.app.auth().signInWithCredential(oAuthCredential);\n    }\n\n    if (\"email\" in credentials && \"password\" in credentials) {\n      const { email, password } = credentials;\n      return this.app\n        .auth()\n        .signInWithEmailAndPassword(email, password);\n    }\n\n    throw new Error(\n      `Either {email,password}, {customToken}, or {idToken,providerId} is required`\n    );\n  }\n\n  logout() {\n    return this.app.auth().signOut();\n  }\n\n  public async createCustomToken(): Promise<CustomToken> {\n    const [error, customToken] = await this.app\n      .functions()\n      .httpsCallable(\"createCustomToken\")()\n      .then(({ data }) => [null, data])\n      .catch((error) => [error, null]);\n\n    if (error) {\n      return Promise.reject(error);\n    }\n\n    return customToken;\n  }\n\n  async getDevices() {\n    const userId = this.user?.uid;\n\n    if (!userId) {\n      return Promise.reject(`Please login.`);\n    }\n\n    const snapshot = await this.app\n      .database()\n      .ref(this.getUserDevicesPath())\n      .once(\"value\");\n\n    const userDevices: UserDevices | null = snapshot.val();\n\n    return this.userDevicesToDeviceInfoList(userDevices);\n  }\n\n  async addDevice(deviceId: string): Promise<void> {\n    const userId = this.user?.uid;\n\n    if (!userId) {\n      return Promise.reject(`Please login.`);\n    }\n\n    const devices = await this.getDevices().catch((error) => {\n      console.log(error);\n    });\n\n    const deviceAlreadyInAccount =\n      devices &&\n      devices.length &&\n      devices.map(({ deviceId }) => deviceId).includes(deviceId);\n\n    if (deviceAlreadyInAccount) {\n      return Promise.reject(\n        `The device is already added to this account.`\n      );\n    }\n\n    const [isValid, invalidErrorMessage] = await this.isDeviceIdValid(\n      deviceId\n    )\n      .then((isValid) => [isValid])\n      .catch((error) => [false, error]);\n\n    if (!isValid) {\n      return Promise.reject(invalidErrorMessage);\n    }\n\n    const claimedByPath = this.getDeviceClaimedByPath(deviceId);\n    const userDevicePath = this.getUserClaimedDevicePath(deviceId);\n\n    const [hasError, errorMessage] = await this.app\n      .database()\n      .ref()\n      .update({\n        [claimedByPath]: userId,\n        [userDevicePath]: {\n          claimedOn: SERVER_TIMESTAMP\n        }\n      })\n      .then(() => [false])\n      .catch((error) => [true, error]);\n\n    if (hasError) {\n      return Promise.reject(errorMessage);\n    }\n  }\n\n  async removeDevice(deviceId: string): Promise<void> {\n    const userId = this.user?.uid;\n\n    if (!userId) {\n      return Promise.reject(`Please login.`);\n    }\n\n    const claimedByPath = this.getDeviceClaimedByPath(deviceId);\n    const userDevicePath = this.getUserClaimedDevicePath(deviceId);\n\n    const claimedByRef = this.app.database().ref(claimedByPath);\n    const userDeviceRef = this.app.database().ref(userDevicePath);\n\n    const [hasError, errorMessage] = await Promise.all([\n      claimedByRef.remove(),\n      userDeviceRef.remove()\n    ])\n      .then(() => [false])\n      .catch((error) => [true, error]);\n\n    if (hasError) {\n      return Promise.reject(errorMessage);\n    }\n  }\n\n  async isDeviceIdValid(deviceId: string): Promise<boolean> {\n    // hex string of 32 characters\n    const hexRegEx = /[0-9A-Fa-f]{32}/g;\n    if (\n      !deviceId ||\n      deviceId.length !== 32 ||\n      !hexRegEx.test(deviceId)\n    ) {\n      return Promise.reject(\"The device id is incorrectly formatted.\");\n    }\n\n    const claimedByPath = this.getDeviceClaimedByPath(deviceId);\n    const claimedByRef = this.app.database().ref(claimedByPath);\n\n    const claimedBySnapshot = await claimedByRef\n      .once(\"value\")\n      .catch(() => null);\n\n    if (!claimedBySnapshot || claimedBySnapshot.exists()) {\n      return Promise.reject(\"The device has already been claimed.\");\n    }\n\n    return true;\n  }\n\n  onUserDevicesChange(): Observable<DeviceInfo[]> {\n    return this.onAuthStateChanged().pipe(\n      switchMap((user) => {\n        if (!user) {\n          return empty();\n        }\n\n        const userDevicesPath = this.getUserDevicesPath();\n        const userDevicesRef = this.app.database().ref(userDevicesPath);\n\n        return fromEventPattern(\n          (handler) => userDevicesRef.on(\"value\", handler),\n          (handler) => userDevicesRef.off(\"value\", handler)\n        ).pipe(\n          map((snapshot: firebase.database.DataSnapshot) =>\n            snapshot.val()\n          ),\n          switchMap((userDevices: UserDevices | null) => {\n            return from(this.userDevicesToDeviceInfoList(userDevices));\n          })\n        );\n      })\n    );\n  }\n\n  private async userDevicesToDeviceInfoList(\n    userDevices: UserDevices | null\n  ): Promise<DeviceInfo[]> {\n    const devicesInfoSnapshots = Object.keys(\n      userDevices ?? {}\n    ).map((deviceId) =>\n      this.app\n        .database()\n        .ref(this.getDeviceInfoPath(deviceId))\n        .once(\"value\")\n    );\n\n    const devicesList: DeviceInfo[] = await Promise.all(\n      devicesInfoSnapshots\n    ).then((snapshots) => snapshots.map((snapshot) => snapshot.val()));\n\n    const validDevices = devicesList.filter((device) => !!device);\n\n    validDevices.sort((a, b) => {\n      return (\n        userDevices[a.deviceId].claimedOn -\n        userDevices[b.deviceId].claimedOn\n      );\n    });\n\n    return validDevices;\n  }\n\n  public async hasDevicePermission(deviceId: string): Promise<boolean> {\n    const deviceInfoPath = this.getDeviceInfoPath(deviceId);\n\n    const hasPermission = await this.app\n      .database()\n      .ref(deviceInfoPath)\n      .once(\"value\")\n      .then(() => true)\n      .catch(() => false);\n\n    return hasPermission;\n  }\n\n  private getDeviceClaimedByPath(deviceId: string): string {\n    return `devices/${deviceId}/status/claimedBy`;\n  }\n\n  private getUserClaimedDevicePath(deviceId: string): string {\n    const userId = this.user.uid;\n    return `users/${userId}/devices/${deviceId}`;\n  }\n\n  private getUserDevicesPath(): string {\n    const userId = this.user.uid;\n    return `users/${userId}/devices`;\n  }\n\n  private getDeviceInfoPath(deviceId: string): string {\n    return `devices/${deviceId}/info`;\n  }\n}\n","import firebase from \"firebase/app\";\n\nconst SERVER_TIMESTAMP = firebase.database.ServerValue.TIMESTAMP;\n\nexport interface IDevice {\n  info: any;\n  status: any;\n  subscriptions: any;\n  metrics: any;\n}\n\n/**\n * @hidden\n */\nexport const createDeviceStore = (\n  app,\n  deviceId,\n  subscriptionManager\n) => {\n  const deviceRef = app.database().ref(`devices/${deviceId}`);\n  const clientId = deviceRef.child(\"subscriptions\").push().key;\n  const clientRef = deviceRef.child(`clients/${clientId}`);\n  let listenersToRemove = [];\n\n  const set = (namespace, payload) => {\n    return deviceRef.child(namespace).set(payload);\n  };\n\n  const push = (namespace, payload) => {\n    return deviceRef.child(namespace).push(payload);\n  };\n\n  const update = (namespace, payload) => {\n    return deviceRef.child(namespace).update(payload);\n  };\n\n  const on = (eventType: any = \"value\", namespace, callback) => {\n    const listener = deviceRef\n      .child(namespace)\n      .on(eventType, (snapshot) => {\n        callback(snapshot.val(), snapshot);\n      });\n\n    listenersToRemove.push(() => {\n      deviceRef.child(namespace).off(eventType, listener);\n    });\n\n    return listener;\n  };\n\n  const off = (namespace, eventType, listener?) => {\n    if (listener) {\n      deviceRef.child(namespace).off(eventType, listener);\n    } else {\n      deviceRef.child(namespace).off(eventType);\n    }\n  };\n\n  const once = async (namespace, eventType = \"value\") => {\n    const snapshot = await deviceRef.child(namespace).once(eventType);\n    return snapshot.val();\n  };\n\n  const remove = (namespace) => {\n    deviceRef.child(namespace).remove();\n  };\n\n  const bindListener = (\n    eventType: string,\n    namespace: string,\n    callback: (res: any) => void,\n    overrideResponse?: any\n  ) => {\n    on(eventType, namespace, (data) => {\n      if (data !== null) {\n        off(namespace, eventType);\n        const response = overrideResponse ? overrideResponse : data;\n        callback(response);\n      }\n    });\n  };\n\n  const lastOfChildValue = async (namespace, key, value) => {\n    const snapshot = await deviceRef\n      .child(namespace)\n      .orderByChild(key)\n      .equalTo(value)\n      .limitToLast(1)\n      .once(\"value\");\n    const results = snapshot.val();\n    const [match] = Object.values(results || {});\n    return match || null;\n  };\n\n  // Add client connections and subscriptions to db and remove them when offline\n  const connectedListener = app\n    .database()\n    .ref(\".info/connected\")\n    .on(\"value\", (snapshot) => {\n      if (!snapshot.val()) {\n        return;\n      }\n\n      clientRef\n        .onDisconnect()\n        .remove()\n        .then(() => {\n          clientRef.set(SERVER_TIMESTAMP);\n\n          // NOTION-115: Re-subscribe when internet connection is lost and regained\n          update(\"subscriptions\", subscriptionManager.get()).then(\n            () => {\n              subscriptionManager.toList().forEach((subscription) => {\n                const childPath = `subscriptions/${subscription.id}`;\n                deviceRef.child(childPath).onDisconnect().remove();\n              });\n            }\n          );\n        });\n    });\n\n  listenersToRemove.push(() => {\n    app\n      .database()\n      .ref(\".info/connected\")\n      .off(\"value\", connectedListener);\n  });\n\n  return {\n    set,\n    once,\n    update,\n    lastOfChildValue,\n    onNamespace: (namespace: string, callback: Function): Function => {\n      return on(\"value\", namespace, (data: any) => {\n        callback(data);\n      });\n    },\n    offNamespace: (namespace: string, listener: Function): void => {\n      off(namespace, \"value\", listener);\n    },\n    dispatchAction: async (action) => {\n      const snapshot = await push(\"actions\", action);\n      const actionId = snapshot.key;\n      const actionPath = `actions/${actionId}`;\n\n      snapshot.onDisconnect().remove();\n\n      if (action.responseRequired) {\n        const responseTimeout = action.responseTimeout || 600000; // defaults to 10 minutes\n        const timeout = new Promise((_, reject) => {\n          const id = setTimeout(() => {\n            clearTimeout(id);\n            snapshot.remove();\n            reject(\n              `Action response timed out in ${responseTimeout}ms.`\n            );\n          }, responseTimeout);\n        });\n\n        const response = new Promise((resolve) => {\n          bindListener(\"value\", `${actionPath}/response`, resolve);\n        });\n\n        return Promise.race([response, timeout]);\n      }\n\n      return actionId;\n    },\n    nextMetric: async (\n      metricName: string,\n      metricValue: { [label: string]: any }\n    ) => {\n      set(`metrics/${metricName}`, metricValue);\n    },\n    onMetric: (subscription, callback: Function) => {\n      const { atomic, metric, labels } = subscription;\n      const child = atomic\n        ? `metrics/${metric}`\n        : `metrics/${metric}/${labels[0]}`;\n      return on(\"value\", child, (data) => {\n        if (data !== null) {\n          callback(data);\n        }\n      });\n    },\n    subscribeToMetric: (subscription) => {\n      const id = deviceRef.child(\"subscriptions\").push().key;\n      const childPath = `subscriptions/${id}`;\n      const subscriptionCreated = {\n        id,\n        clientId,\n        ...subscription\n      };\n      set(childPath, subscriptionCreated);\n\n      deviceRef.child(childPath).onDisconnect().remove();\n\n      return subscriptionCreated;\n    },\n    unsubscribeFromMetric: (subscription) => {\n      remove(`subscriptions/${subscription.id}`);\n    },\n    removeMetricListener(subscription, listener: Function) {\n      const { atomic, metric, labels } = subscription;\n      const child = atomic\n        ? `metrics/${metric}`\n        : `metrics/${metric}/${labels[0]}`;\n      off(child, \"value\", listener);\n    },\n    disconnect() {\n      clientRef.remove();\n      listenersToRemove.forEach((removeListener) => {\n        removeListener();\n      });\n      subscriptionManager\n        .toList()\n        .filter((subscription) => subscription.clientId === clientId)\n        .forEach((subscription) => {\n          const childPath = `subscriptions/${subscription.id}`;\n          deviceRef.child(childPath).remove();\n        });\n    }\n  };\n};\n","import firebase from \"firebase/app\";\n\nimport { FirebaseApp } from \"./FirebaseApp\";\nimport { createDeviceStore } from \"./deviceStore\";\nimport { NotionDependencies } from \"../../types/options\";\n\nconst SERVER_TIMESTAMP = firebase.database.ServerValue.TIMESTAMP;\n\ntype FirebaseDeviceOptions = {\n  deviceId: string;\n  firebaseApp: FirebaseApp;\n  dependencies: NotionDependencies;\n};\n\n/**\n * @hidden\n */\nexport class FirebaseDevice {\n  static serverType = \"firebase\";\n  protected app: firebase.app.App;\n  protected deviceStore;\n\n  constructor({\n    deviceId,\n    firebaseApp,\n    dependencies\n  }: FirebaseDeviceOptions) {\n    this.app = firebaseApp.app;\n    this.deviceStore = createDeviceStore(\n      this.app,\n      deviceId,\n      dependencies.subscriptionManager\n    );\n  }\n\n  public get timestamp(): any {\n    return SERVER_TIMESTAMP;\n  }\n\n  public dispatchAction(action): Promise<any> {\n    return this.deviceStore.dispatchAction(action);\n  }\n\n  public async getInfo(): Promise<any> {\n    return await this.deviceStore.once(\"info\");\n  }\n\n  public onNamespace(namespace: string, callback: Function): Function {\n    return this.deviceStore.onNamespace(namespace, callback);\n  }\n\n  public async onceNamespace(namespace: string): Promise<any> {\n    return await this.deviceStore.once(namespace);\n  }\n\n  public offNamespace(namespace: string, listener: Function): void {\n    this.deviceStore.offNamespace(namespace, listener);\n  }\n\n  public async getTimesync(): Promise<number> {\n    const response = await this.dispatchAction({\n      command: \"timesync\",\n      action: \"get\",\n      responseRequired: true,\n      responseTimeout: 250\n    });\n    return response.timestamp;\n  }\n\n  /**\n   * Pushes metric for each subscriptions in path:\n   * /devices/:deviceId/metrics/:metricName\n   */\n  public nextMetric(\n    metricName: string,\n    metricValue: { [label: string]: any }\n  ): void {\n    this.deviceStore.nextMetric(metricName, metricValue);\n  }\n\n  /**\n   * Listens for metrics in path:\n   * /devices/:deviceId/metrics/:metricName\n   */\n  public onMetric(subscription, callback): Function {\n    return this.deviceStore.onMetric(subscription, callback);\n  }\n\n  /**\n   * Creates a new and unique subscription in path:\n   * /devices/:deviceId/subscriptions/:subscriptionId\n   * E.g. /devices/device1/subscriptions/subscription3\n   *\n   * @param subscription\n   * @returns subscriptionId\n   */\n  public subscribeToMetric(subscription) {\n    const subscriptionId = this.deviceStore.subscribeToMetric(\n      subscription\n    );\n    return subscriptionId;\n  }\n\n  /**\n   * Removes subscription in path:\n   * /devices/:deviceId/subscriptions/:subscriptionId\n   *\n   * @param subscription\n   */\n  public unsubscribeFromMetric(subscription): void {\n    this.deviceStore.unsubscribeFromMetric(subscription);\n  }\n\n  /**\n   * Removes metric listener\n   * /devices/:deviceId/metric\n   * or\n   * /devices/:deviceId/metric/label\n   *\n   * @param subscription\n   * @param listener\n   */\n  public removeMetricListener(subscription, listener: Function): void {\n    this.deviceStore.removeMetricListener(subscription, listener);\n  }\n\n  public async changeSettings(settings): Promise<void> {\n    return this.deviceStore.update(\"settings\", settings);\n  }\n\n  public async getSkill(bundleId): Promise<any> {\n    return await this.deviceStore.lastOfChildValue(\n      \"skills\",\n      \"bundleId\",\n      bundleId\n    );\n  }\n\n  public disconnect() {\n    this.deviceStore.disconnect();\n  }\n}\n","export * from \"./FirebaseApp\";\nexport * from \"./FirebaseUser\";\nexport * from \"./FirebaseDevice\";\n","import io from \"socket.io-client\";\nimport { Subscription } from \"../../types/subscriptions\";\n\n/**\n * @hidden\n */\ntype WebsocketOptions = {\n  deviceId: string;\n  socketUrl?: string;\n  secure?: boolean;\n};\n\nconst defaultOptions = {\n  secure: true\n};\n\n/**\n * @hidden\n */\nexport class WebsocketClient {\n  static serverType: string = \"websocket\";\n  private options: WebsocketOptions;\n  protected socket;\n\n  constructor(options: WebsocketOptions) {\n    this.options = Object.freeze({\n      ...defaultOptions,\n      ...options\n    });\n\n    this.socket = io(this.options.socketUrl, {\n      path: `/${this.options.deviceId}`\n    });\n  }\n\n  public onMetric(\n    subscription: Subscription,\n    callback: Function\n  ): Function {\n    return this.socket.on(`metrics/${subscription.id}`, callback);\n  }\n\n  public removeMetricListener(\n    subscription: Subscription,\n    listener: Function\n  ): void {\n    this.socket.off(`metrics/${subscription.id}`, listener);\n  }\n\n  public disconnect(): void {\n    this.socket.removeAllListeners();\n    if (this.socket.connected) {\n      this.socket.disconnect();\n    }\n  }\n}\n","import { pipe, of, empty, Observable } from \"rxjs\";\nimport { flatMap, withLatestFrom } from \"rxjs/operators\";\nimport { DeviceStatus } from \"../types/status\";\n\ntype Options = {\n  status$: Observable<DeviceStatus>;\n  allowWhileOnSleepMode: boolean;\n};\n\nexport function whileOnline({\n  status$,\n  allowWhileOnSleepMode\n}: Options) {\n  return pipe(\n    withLatestFrom(status$),\n    flatMap(([value, status]: [any, DeviceStatus]) =>\n      shouldAllowMetrics(status, allowWhileOnSleepMode)\n        ? of(value)\n        : empty()\n    )\n  );\n}\n\nfunction shouldAllowMetrics(\n  status: DeviceStatus,\n  allowWhileOnSleepMode: boolean\n) {\n  return (\n    status.state === \"online\" &&\n    (allowWhileOnSleepMode ? true : !status.sleepMode)\n  );\n}\n","import { timer, pipe, range, Observable } from \"rxjs\";\nimport { map, concat, filter, take } from \"rxjs/operators\";\nimport { bufferCount, concatMap, switchMap } from \"rxjs/operators\";\nimport outliers from \"outliers\";\n\nimport { whileOnline } from \"../utils/whileOnline\";\nimport { DeviceStatus } from \"../types/status\";\n\ntype Options = {\n  getTimesync: () => Promise<number>;\n  status$: Observable<DeviceStatus>;\n  bufferSize?: number;\n  updateInterval?: number;\n};\n\nconst defaultOptions = {\n  bufferSize: 100,\n  updateInterval: 1 * 60 * 1000 // every minute\n};\n\nexport class Timesync {\n  options: Options;\n  _offset: number = 0;\n\n  constructor(options: Options) {\n    this.options = {\n      ...defaultOptions,\n      ...options\n    };\n\n    this.start();\n  }\n\n  public start(): void {\n    const { bufferSize, updateInterval, status$ } = this.options;\n\n    const burst$ = range(0, bufferSize);\n    const timer$ = timer(updateInterval, updateInterval).pipe(\n      map((i) => bufferSize + i),\n      whileOnline({\n        status$,\n        allowWhileOnSleepMode: true\n      })\n    );\n\n    const firstTimeDeviceIsOnline$ = status$.pipe(\n      filter((status: DeviceStatus) => status.state === \"online\"),\n      take(1)\n    );\n\n    firstTimeDeviceIsOnline$\n      .pipe(\n        switchMap(() => {\n          return burst$.pipe(\n            concat(timer$),\n            this.toOffset(),\n            bufferCount(bufferSize, 1),\n            this.filterOutliers(),\n            map((list) => this.average(list))\n          );\n        })\n      )\n      .subscribe((offset) => {\n        this._offset = offset;\n      });\n  }\n\n  filterOutliers() {\n    return pipe(\n      map((offsets: number[]): number[] => {\n        return offsets.filter(outliers());\n      })\n    );\n  }\n\n  toOffset() {\n    const { getTimesync } = this.options;\n    return pipe(\n      concatMap(async () => {\n        const requestStartTime = Date.now();\n        const [error, serverTime] = await getTimesync()\n          .then((offset) => [null, offset])\n          .catch((error) => [error]);\n\n        if (error) {\n          return 0;\n        }\n\n        const responseEndTime = Date.now();\n        const oneWayDuration = (responseEndTime - requestStartTime) / 2;\n        const offset = responseEndTime - oneWayDuration - serverTime;\n        return offset;\n      })\n    );\n  }\n\n  private average(list: number[]): number {\n    return Math.round(\n      list.reduce((acc, number) => acc + number) / list.length\n    );\n  }\n\n  public get offset(): number {\n    return this._offset;\n  }\n\n  public get timestamp(): number {\n    return Date.now() + this._offset;\n  }\n}\n","export * from \"./Timesync\";\n","import { Subscription, Subscriptions } from \"../types/subscriptions\";\n\n/**\n * @hidden\n */\nexport class SubscriptionManager {\n  private _subscriptions: Subscriptions = {};\n\n  public get(): Subscriptions {\n    return this._subscriptions;\n  }\n\n  public toList(): Subscription[] {\n    return Object.values(this._subscriptions);\n  }\n\n  public add(subscription: Subscription): void {\n    this._subscriptions[subscription.id] = subscription;\n  }\n\n  public remove(subscription: Subscription): void {\n    if (!(subscription.id in this._subscriptions)) {\n      return;\n    }\n\n    Reflect.deleteProperty(this._subscriptions, subscription.id);\n  }\n}\n","import {\n  Observable,\n  BehaviorSubject,\n  fromEventPattern,\n  empty\n} from \"rxjs\";\nimport { FirebaseApp, FirebaseUser, FirebaseDevice } from \"./firebase\";\nimport { WebsocketClient } from \"./websocket\";\nimport { Timesync } from \"../timesync\";\nimport { SubscriptionManager } from \"../subscriptions/SubscriptionManager\";\nimport { Client } from \"../types/client\";\nimport { Actions } from \"../types/actions\";\nimport { Metrics } from \"../types/metrics\";\nimport { NotionOptions } from \"../types/options\";\nimport { SkillsClient, DeviceSkill } from \"../types/skill\";\nimport {\n  Credentials,\n  CustomToken,\n  EmailAndPassword\n} from \"../types/credentials\";\nimport { ChangeSettings } from \"../types/settings\";\nimport { Subscription } from \"../types/subscriptions\";\nimport { DeviceStatus } from \"../types/status\";\nimport { DeviceInfo, DeviceSelector } from \"../types/deviceInfo\";\nimport { map, switchMap, filter, shareReplay } from \"rxjs/operators\";\n\nexport {\n  credentialWithLink,\n  createUser,\n  SERVER_TIMESTAMP\n} from \"./firebase\";\n\n/**\n * @hidden\n */\nexport class ApiClient implements Client {\n  public user;\n  protected options: NotionOptions;\n  protected firebaseApp: FirebaseApp;\n  protected firebaseUser: FirebaseUser;\n  protected firebaseDevice: FirebaseDevice;\n  protected websocket: WebsocketClient;\n  protected timesync: Timesync;\n  protected subscriptionManager: SubscriptionManager;\n  public defaultServerType: string = FirebaseDevice.serverType;\n  public localServerType: string = WebsocketClient.serverType;\n\n  /**\n   * @internal\n   */\n  private _selectedDevice: BehaviorSubject<DeviceInfo | null> = new BehaviorSubject(\n    undefined\n  );\n\n  constructor(options: NotionOptions) {\n    this.options = options;\n    this.subscriptionManager = new SubscriptionManager();\n    this.firebaseApp = new FirebaseApp(options);\n    this.firebaseUser = new FirebaseUser(this.firebaseApp);\n\n    this.firebaseUser.onAuthStateChanged().subscribe((user) => {\n      this.user = user;\n    });\n\n    this.onDeviceChange().subscribe((device) => {\n      if (this.firebaseDevice) {\n        this.firebaseDevice.disconnect();\n      }\n\n      if (!device) {\n        return;\n      }\n\n      this.firebaseDevice = new FirebaseDevice({\n        deviceId: device.deviceId,\n        firebaseApp: this.firebaseApp,\n        dependencies: {\n          subscriptionManager: this.subscriptionManager\n        }\n      });\n\n      if (this.options.timesync) {\n        this.timesync = new Timesync({\n          status$: this.status(),\n          getTimesync: this.firebaseDevice.getTimesync.bind(\n            this.firebaseDevice\n          )\n        });\n      }\n    });\n  }\n\n  public onDeviceChange(): Observable<DeviceInfo> {\n    return this._selectedDevice.asObservable().pipe(\n      shareReplay(1),\n      filter((value) => value !== undefined)\n    );\n  }\n\n  // Automatically select device when user logs in\n  private async setAutoSelectedDevice(): Promise<DeviceInfo | null> {\n    // Select based on `deviceId` passed\n    if (this.options.deviceId) {\n      return await this.selectDevice((devices) => {\n        return devices.find(\n          (device) => device.deviceId === this.options.deviceId\n        );\n      });\n    }\n\n    // Auto select first-claimed device\n    if (!this.options.deviceId && this.options.autoSelectDevice) {\n      return await this.selectDevice((devices) => {\n        // Auto select first device\n        return devices[0];\n      });\n    }\n\n    return null;\n  }\n\n  public async setWebsocket(\n    socketUrl: string,\n    deviceId: string\n  ): Promise<void> {\n    this.websocket = new WebsocketClient({ socketUrl, deviceId });\n  }\n\n  public unsetWebsocket(): void {\n    if (this.websocket) {\n      this.websocket.disconnect();\n      this.websocket = null;\n    }\n  }\n\n  public get actions(): Actions {\n    return {\n      dispatch: (action) => {\n        return this.firebaseDevice.dispatchAction(action);\n      }\n    };\n  }\n\n  public async disconnect(): Promise<any> {\n    if (this.websocket) {\n      this.websocket.disconnect();\n    }\n\n    return this.firebaseApp.disconnect();\n  }\n\n  public async getInfo(): Promise<any> {\n    return await this.firebaseDevice.getInfo();\n  }\n\n  public async login(credentials: Credentials): Promise<any> {\n    if (this.user) {\n      return Promise.reject(`Already logged in.`);\n    }\n\n    const auth = await this.firebaseUser.login(credentials);\n    const selectedDevice = await this.setAutoSelectedDevice();\n\n    return {\n      ...auth,\n      selectedDevice\n    };\n  }\n\n  public async logout(): Promise<any> {\n    if (this.firebaseDevice) {\n      this.firebaseDevice.disconnect();\n    }\n\n    return await this.firebaseUser.logout();\n  }\n\n  public onAuthStateChanged() {\n    return this.firebaseUser.onAuthStateChanged().pipe(\n      switchMap(async (user) => {\n        if (!user) {\n          return null;\n        }\n\n        const selectedDevice = this.didSelectDevice()\n          ? await this.getSelectedDevice()\n          : await this.setAutoSelectedDevice();\n\n        return {\n          ...user,\n          selectedDevice\n        };\n      })\n    );\n  }\n\n  public getDevices() {\n    return this.firebaseUser.getDevices();\n  }\n\n  public addDevice(deviceId: string): Promise<void> {\n    return this.firebaseUser.addDevice(deviceId);\n  }\n\n  public async removeDevice(deviceId: string): Promise<void> {\n    const [hasError, errorMessage] = await this.firebaseUser\n      .removeDevice(deviceId)\n      .then(() => [false])\n      .catch((error) => [true, error]);\n\n    if (hasError) {\n      return Promise.reject(errorMessage);\n    }\n\n    const selectedDevice = this._selectedDevice.getValue();\n\n    if (selectedDevice?.deviceId === deviceId) {\n      this._selectedDevice.next(null);\n    }\n  }\n\n  public onUserDevicesChange(): Observable<DeviceInfo[]> {\n    return this.firebaseUser.onUserDevicesChange();\n  }\n\n  public didSelectDevice(): boolean {\n    return !!this._selectedDevice.getValue();\n  }\n\n  public async selectDevice(\n    deviceSelector: DeviceSelector\n  ): Promise<DeviceInfo> {\n    const devices = await this.getDevices();\n\n    if (!devices) {\n      return Promise.reject(\n        `Did not find any devices for this user. Make sure your device is claimed by your Neurosity account.`\n      );\n    }\n\n    const deviceTupleSelector = (devices: DeviceInfo[]) =>\n      devices.find((device) => {\n        if (!Array.isArray(deviceSelector)) {\n          return false;\n        }\n\n        const [deviceKey, deviceValue] = deviceSelector;\n        return (\n          JSON.stringify(device?.[deviceKey]) ===\n          JSON.stringify(deviceValue)\n        );\n      });\n\n    const device =\n      typeof deviceSelector === \"function\"\n        ? deviceSelector(devices)\n        : deviceTupleSelector(devices);\n\n    if (!device) {\n      return Promise.reject(\n        `A device was not provided. Try returning a device from the devicesList provided in the callback.`\n      );\n    }\n\n    const hasPermission = await this.firebaseUser.hasDevicePermission(\n      device.deviceId\n    );\n\n    if (!hasPermission) {\n      return Promise.reject(\n        `Rejected device access due to permissions.`\n      );\n    }\n\n    this._selectedDevice.next(device);\n\n    return device;\n  }\n\n  public async getSelectedDevice(): Promise<DeviceInfo> {\n    const selectedDevice = this._selectedDevice.getValue();\n\n    if (!selectedDevice) {\n      return Promise.reject(`There is no device currently selected.`);\n    }\n\n    const devices = await this.getDevices();\n\n    if (!devices) {\n      return Promise.reject(\n        `Did not find any devices for this user. Make sure your device is claimed by your Neurosity account.`\n      );\n    }\n\n    return devices.find(\n      (device) => device.deviceId === selectedDevice.deviceId\n    );\n  }\n\n  public status(): Observable<DeviceStatus> {\n    return this.observeNamespace(\"status\").pipe(\n      map((status) => {\n        if (!status) {\n          return status;\n        }\n\n        // remove internal properties that start with \"__\"\n        return Object.entries(status).reduce((acc, [key, value]) => {\n          if (!key.startsWith(\"__\")) {\n            acc[key] = value;\n          }\n          return acc;\n        }, {});\n      })\n    );\n  }\n\n  public observeNamespace(namespace: string): Observable<any> {\n    const namespaceValues$ = fromEventPattern(\n      (handler) => this.firebaseDevice.onNamespace(namespace, handler),\n      (handler) => this.firebaseDevice.offNamespace(namespace, handler)\n    );\n\n    return this.onDeviceChange().pipe(\n      switchMap((selectedDevice) => {\n        return selectedDevice ? namespaceValues$ : empty();\n      })\n    );\n  }\n\n  public async onceNamespace(namespace: string): Promise<any> {\n    return await this.firebaseDevice.onceNamespace(namespace);\n  }\n\n  public get metrics(): Metrics {\n    const isWebsocketMetric = (subscription: Subscription): boolean =>\n      subscription.serverType === WebsocketClient.serverType;\n\n    return {\n      next: (metricName: string, metricValue: any): void => {\n        this.firebaseDevice.nextMetric(metricName, metricValue);\n      },\n      on: (\n        subscription: Subscription,\n        callback: Function\n      ): Function => {\n        if (isWebsocketMetric(subscription)) {\n          return this.websocket.onMetric(subscription, callback);\n        } else {\n          return this.firebaseDevice.onMetric(subscription, callback);\n        }\n      },\n      subscribe: (subscription: Subscription): Subscription => {\n        const subscriptionCreated = this.firebaseDevice.subscribeToMetric(\n          subscription\n        );\n        this.subscriptionManager.add(subscriptionCreated);\n        return subscriptionCreated;\n      },\n      unsubscribe: (\n        subscription: Subscription,\n        listener: Function\n      ): void => {\n        this.subscriptionManager.remove(subscription);\n        this.firebaseDevice.unsubscribeFromMetric(subscription);\n\n        if (isWebsocketMetric(subscription)) {\n          if (this.websocket) {\n            this.websocket.removeMetricListener(subscription, listener);\n          }\n        } else {\n          this.firebaseDevice.removeMetricListener(\n            subscription,\n            listener\n          );\n        }\n      }\n    };\n  }\n\n  public createAccount(credentials: EmailAndPassword) {\n    return this.firebaseUser.createAccount(credentials);\n  }\n\n  public deleteAccount() {\n    return this.firebaseUser.deleteAccount();\n  }\n\n  public createCustomToken(): Promise<CustomToken> {\n    return this.firebaseUser.createCustomToken();\n  }\n\n  public get skills(): SkillsClient {\n    return {\n      get: async (bundleId: string): Promise<DeviceSkill> => {\n        return this.firebaseDevice.getSkill(bundleId);\n      }\n    };\n  }\n\n  public get timestamp(): number {\n    return this.options.timesync ? this.timesync.timestamp : Date.now();\n  }\n\n  public getTimesyncOffset(): number {\n    return this.timesync.offset;\n  }\n\n  public changeSettings(settings: ChangeSettings): Promise<void> {\n    return this.firebaseDevice.changeSettings(settings);\n  }\n\n  public goOffline() {\n    this.firebaseApp.goOffline();\n  }\n\n  public goOnline() {\n    this.firebaseApp.goOnline();\n  }\n\n  /**\n   * @internal\n   */\n  public __getApp() {\n    return this.firebaseApp.app;\n  }\n}\n","import { metrics } from \"@neurosity/ipk\";\nimport { NotionOptions } from \"../types/options\";\n\nexport const isNotionMetric = (metric: string): boolean =>\n  Object.keys(metrics).includes(metric);\n\nexport const getLabels = (metric: string): string[] =>\n  Object.keys(metrics[metric]);\n\nexport const hasInvalidLabels = (\n  metric: string,\n  labels: string[]\n): boolean => {\n  const validLabels = getLabels(metric);\n  return !labels.every((label) => validLabels.includes(label));\n};\n\nexport const isMetricDisallowed = (\n  metricName: string,\n  options: NotionOptions\n): boolean =>\n  \"skill\" in options &&\n  \"metrics\" in options.skill &&\n  !options.skill.metrics.includes(metricName);\n\nexport const validate = (\n  metric: string,\n  labels: string[],\n  options: NotionOptions\n): Error | false => {\n  const validLabels = getLabels(metric).join(\", \");\n\n  if (!labels.length) {\n    return new Error(\n      `At least one label is required for ${metric} metric. Please add one of the following labels: ${validLabels}`\n    );\n  }\n\n  if (isMetricDisallowed(metric, options)) {\n    return new Error(\n      `No permission to access the ${metric} metric. To access this metric, edit the skill's permissions`\n    );\n  }\n\n  if (hasInvalidLabels(metric, labels)) {\n    return new Error(\n      `One ore more labels provided to ${metric} are invalid. The valid labels for ${metric} are ${validLabels}`\n    );\n  }\n\n  return false;\n};\n","export const mustSelectDevice = new Error(\n  `A device must be selected. Make sure to call \"notion.selectDevice()\"`\n);\n","import {\n  Observable,\n  BehaviorSubject,\n  throwError,\n  of,\n  empty,\n  from\n} from \"rxjs\";\nimport { map, share, switchMap } from \"rxjs/operators\";\nimport {\n  ApiClient,\n  credentialWithLink,\n  createUser,\n  SERVER_TIMESTAMP\n} from \"./api/index\";\nimport { whileOnline } from \"./utils/whileOnline\";\nimport { NotionOptions } from \"./types/options\";\nimport { Training } from \"./types/training\";\nimport { SkillInstance } from \"./types/skill\";\nimport {\n  Credentials,\n  EmailAndPassword,\n  CustomToken\n} from \"./types/credentials\";\nimport { Settings, ChangeSettings } from \"./types/settings\";\nimport { AwarenessLabels } from \"./types/awareness\";\nimport { SignalQuality } from \"./types/signalQuality\";\nimport { Kinesis } from \"./types/kinesis\";\nimport { Calm } from \"./types/calm\";\nimport { Focus } from \"./types/focus\";\nimport {\n  getLabels,\n  validate,\n  isNotionMetric\n} from \"./utils/subscription\";\nimport {\n  PendingSubscription,\n  Subscription\n} from \"./types/subscriptions\";\nimport {\n  BrainwavesLabel,\n  Epoch,\n  PowerByBand,\n  PSD\n} from \"./types/brainwaves\";\nimport { Accelerometer } from \"./types/accelerometer\";\nimport { DeviceInfo } from \"./types/deviceInfo\";\nimport { DeviceStatus } from \"./types/status\";\nimport { Action } from \"./types/actions\";\nimport * as errors from \"./utils/errors\";\n\nconst defaultOptions = {\n  timesync: false,\n  autoSelectDevice: true\n};\n\n/**\n * Example\n * ```typescript\n * import { Notion } from \"@neurosity/notion\";\n *\n * const notion = new Notion();\n * ```\n */\nexport class Notion {\n  /**\n   * @hidden\n   */\n  protected options: NotionOptions;\n\n  /**\n   * @hidden\n   */\n  protected api: ApiClient;\n\n  /**\n   * @internal\n   */\n  private _localModeSubject: BehaviorSubject<boolean> = new BehaviorSubject(\n    false\n  );\n\n  /**\n   *\n   * @hidden\n   */\n  static credentialWithLink = credentialWithLink;\n\n  /**\n   *\n   * @hidden\n   */\n  static createUser = createUser;\n\n  /**\n   *\n   * @hidden\n   */\n  static SERVER_TIMESTAMP = SERVER_TIMESTAMP;\n\n  /**\n   * Creates new instance of Notion\n   * \n   * ```typescript\n   * const notion = new Notion();\n   * ```\n\n   * @param options\n   */\n  constructor(options: NotionOptions = {}) {\n    this.options = Object.freeze({\n      ...defaultOptions,\n      ...options\n    });\n\n    this.api = new ApiClient(this.options);\n  }\n\n  /**\n   * Starts user session\n   *\n   * ```typescript\n   * await notion.login({\n   *   email: \"...\",\n   *   password: \"...\"\n   * });\n   * ```\n   *\n   * @param credentials\n   */\n  public async login(credentials: Credentials): Promise<void> {\n    return await this.api.login(credentials);\n  }\n\n  /**\n   * Ends user session\n   *\n   * ```typescript\n   * await notion.logout();\n   * // session has ended\n   * ```\n   *\n   */\n  public async logout(): Promise<void> {\n    return await this.api.logout();\n  }\n\n  /**\n   * @internal\n   * Not user facing.\n   */\n  public __getApp() {\n    return this.api.__getApp();\n  }\n\n  /**\n   * @internal\n   * Not user facing yet\n   */\n  public onAuthStateChanged(): Observable<any> {\n    return this.api.onAuthStateChanged();\n  }\n\n  /**\n   * @internal\n   * Not user facing yet\n   */\n  public addDevice(deviceId: string): Promise<void> {\n    return this.api.addDevice(deviceId);\n  }\n\n  /**\n   * @internal\n   * Not user facing yet\n   */\n  public removeDevice(deviceId: string): Promise<void> {\n    return this.api.removeDevice(deviceId);\n  }\n\n  /**\n   * @internal\n   * Not user facing yet\n   */\n  public onUserDevicesChange(): Observable<DeviceInfo[]> {\n    return this.api.onUserDevicesChange();\n  }\n\n  /**\n   * Get user devices\n   *\n   * Returns a list of devices claimed by the user authenticated.\n   *\n   * ```typescript\n   * const devices = await notion.getDevices();\n   * console.log(devices);\n   * ```\n   */\n  public async getDevices(): Promise<DeviceInfo[]> {\n    return await this.api.getDevices();\n  }\n\n  /**\n   * Select Device\n   *\n   * Rarely necessary, but useful when the user owns multiple devices.\n   *\n   * A common use case for manually selecting a device is when you wish to build a device dropdown a user can select from, instead of collecting the Device Id from the user ahead of time.\n   *\n   * The 3 steps to manually selecting a device are:\n   *\n   * - Set `autoSelectDevice` to false when instantiating `Notion`.\n   * - Authenticate with your Neurosity account to access your devices by calling the `notion.login(...)` function.\n   * - Call the `notion.selectDevice(...)` function with a device selector function.\n   *\n   * ```typescript\n   * const devices = await notion.selectDevice((devices) =>\n   *   devices.find((device) => device.deviceNickname === \"Notion-A1B\")\n   * );\n   *\n   * console.log(devices);\n   * ```\n   *\n   * > If you own multiple devices, and don't pass `autoSelectDevice`, then the first device on the list will be automatically selected.\n   *\n   * For more info, check out the \"Device Selection\" guide.\n   */\n  public async selectDevice(\n    deviceSelector: (devices: DeviceInfo[]) => DeviceInfo\n  ): Promise<DeviceInfo> {\n    return await this.api.selectDevice(deviceSelector);\n  }\n\n  /**\n   * Get selected device\n   *\n   * ```typescript\n   * const selectedDevice = await notion.getSelectedDevice();\n   * console.log(selectedDevice);\n   * ```\n   */\n\n  public async getSelectedDevice(): Promise<DeviceInfo> {\n    return await this.api.getSelectedDevice();\n  }\n\n  /**\n   * ```typescript\n   * const info = await notion.getInfo();\n   * ```\n   */\n  public async getInfo(): Promise<DeviceInfo> {\n    if (!this.api.didSelectDevice()) {\n      return Promise.reject(errors.mustSelectDevice);\n    }\n\n    return await this.api.getInfo();\n  }\n\n  /**\n   * Observes Local Mode changes\n   *\n   * ```typescript\n   * notion.isLocalMode().subscribe(isLocalMode => {\n   *  console.log(isLocalMode);\n   * });\n   * ```\n   */\n  public isLocalMode(): Observable<boolean> {\n    return this._localModeSubject.asObservable().pipe(share());\n  }\n\n  /**\n   * Observes selected device\n   *\n   * ```typescript\n   * notion.onDeviceChange().subscribe(device => {\n   *  console.log(device);\n   * });\n   * ```\n   */\n  public onDeviceChange(): Observable<DeviceInfo> {\n    return this.api.onDeviceChange();\n  }\n\n  /**\n   * Enables/disables local mode\n   *\n   * With local mode, device metrics like brainwaves, calm, focus, etc will stream\n   * via your local WiFi network and not the default cloud server.\n   *\n   * Local Mode is disabled by default, to enable it:\n   *\n   * ```typescript\n   * await notion.enableLocalMode(true);\n   * ```\n   *\n   * To disable it:\n   *\n   * ```typescript\n   * await notion.enableLocalMode(false);\n   * ```\n   *\n   * Keep in mind:\n   *  - Activity Logging will <em>not work</em> while this setting is enabled.\n   *  - Your Notion must be connected to the same WiFi network as this device to establish communication.\n   *  - An internet connection is still needed to authenticate, get device status and add metric subscriptions.\n   *  - This setting is not global and needs to be set for every Notion app you wish to affect.\n   */\n  public async enableLocalMode(\n    shouldEnable: boolean\n  ): Promise<boolean> {\n    if (typeof shouldEnable !== \"boolean\") {\n      return Promise.reject(\n        new TypeError(\"enableLocalMode can only accept a boolean\")\n      );\n    }\n\n    if (!shouldEnable) {\n      this._localModeSubject.next(shouldEnable);\n      return shouldEnable;\n    }\n\n    const [localModeSupported, error] = await this.api\n      .onceNamespace(\"context/socketUrl\")\n      .then((socketUrl) => {\n        if (!socketUrl) {\n          const error = `Your device's OS does not support localMode. Try updating to the latest OS.`;\n          return [false, new Error(error)];\n        }\n        return [true, null];\n      })\n      .catch((error) => [false, error]);\n\n    if (!localModeSupported) {\n      return Promise.reject(error);\n    }\n\n    this._localModeSubject.next(shouldEnable);\n\n    return shouldEnable;\n  }\n\n  /**\n   * Ends database connection\n   *\n   * ```typescript\n   * await notion.disconnect();\n   * ```\n   */\n  public async disconnect(): Promise<void> {\n    return await this.api.disconnect();\n  }\n\n  /**\n   * @internal\n   * Not user facing\n   */\n  protected socketUrl(): Observable<string> {\n    const { onDeviceSocketUrl } = this.options;\n\n    if (onDeviceSocketUrl) {\n      return of(onDeviceSocketUrl);\n    }\n\n    return this.api.observeNamespace(\"context/socketUrl\");\n  }\n\n  /**\n   * @internal\n   * Not user facing\n   */\n  protected getMetric = (\n    subscription: PendingSubscription\n  ): Observable<any> => {\n    const { metric, labels, atomic } = subscription;\n\n    const error = validate(metric, labels, this.options);\n    if (error) {\n      return throwError(error);\n    }\n\n    const subscribeTo = (serverType: string) =>\n      new Observable((observer) => {\n        const subscriptions: Subscription[] = atomic\n          ? [\n              this.api.metrics.subscribe({\n                metric: metric,\n                labels: labels,\n                atomic: atomic,\n                serverType: serverType\n              })\n            ]\n          : labels.map((label) => {\n              return this.api.metrics.subscribe({\n                metric: metric,\n                labels: [label],\n                atomic: atomic,\n                serverType: serverType\n              });\n            });\n\n        const subscriptionWithListeners = subscriptions.map(\n          (subscription) => ({\n            subscription,\n            listener: this.api.metrics.on(\n              subscription,\n              (...data: any) => {\n                observer.next(...data);\n              }\n            )\n          })\n        );\n\n        return () => {\n          subscriptionWithListeners.forEach(\n            ({ subscription, listener }) => {\n              this.api.metrics.unsubscribe(subscription, listener);\n            }\n          );\n        };\n      });\n\n    return this.onDeviceChange().pipe(\n      switchMap((device) => {\n        if (!device) {\n          return empty();\n        }\n\n        const { deviceId } = device;\n\n        return this.isLocalMode().pipe(\n          switchMap((isLocalMode) => {\n            if (isLocalMode && isNotionMetric(metric)) {\n              return this.socketUrl().pipe(\n                switchMap((socketUrl) =>\n                  this.api.setWebsocket(socketUrl, deviceId)\n                ),\n                switchMap(() => subscribeTo(this.api.localServerType))\n              );\n            }\n\n            this.api.unsetWebsocket();\n            return subscribeTo(this.api.defaultServerType);\n          })\n        );\n      }),\n      whileOnline({\n        status$: this.status(),\n        allowWhileOnSleepMode: false\n      })\n    );\n  };\n\n  /**\n   * @internal\n   * Not user facing\n   */\n  private dispatchAction(action: Action): Promise<Action> | void {\n    if (!this.api.didSelectDevice()) {\n      return Promise.reject(errors.mustSelectDevice);\n    }\n\n    return this.api.actions.dispatch(action);\n  }\n\n  /**\n   * Injects an EEG marker to data stream\n   *\n   * ```typescript\n   * notion.addMarker(\"eyes-closed\");\n   *\n   * // later...\n   *\n   * notion.addMarker(\"eyes-open\");\n   * ```\n   *\n   * @param label Name the label to inject\n   */\n  public addMarker(label: string): void {\n    if (!this.api.didSelectDevice()) {\n      throw errors.mustSelectDevice;\n    }\n\n    if (!label) {\n      throw new Error(\"Notion: a label is required for addMarker\");\n    }\n\n    this.dispatchAction({\n      command: \"marker\",\n      action: \"add\",\n      message: {\n        label,\n        timestamp: this.api.timestamp\n      }\n    });\n  }\n\n  /**\n   * Observes accelerometer data\n   * Supported by Notion 2 and the Crown.\n   *\n   * ```typescript\n   * notion.accelerometer().subscribe(accelerometer => {\n   *   console.log(accelerometer);\n   * });\n   *\n   * // { acceleration: ..., inclination: ..., orientation: ..., pitch: ..., roll: ..., x: ..., y: ..., z: ... }\n   * ```\n   *\n   * @returns Observable of accelerometer metric events\n   */\n  public accelerometer(): Observable<Accelerometer> {\n    const metric = \"accelerometer\";\n\n    return from(this.getSelectedDevice()).pipe(\n      switchMap((selectedDevice) => {\n        const modelVersionWithAccelSupport = 2;\n        const isModelVersion2OrGreater =\n          Number(selectedDevice?.modelVersion) >=\n          modelVersionWithAccelSupport;\n\n        if (!isModelVersion2OrGreater) {\n          return throwError(\n            new Error(\n              `The ${metric} metric is not supported by this device. Model version ${modelVersionWithAccelSupport} or greater required.`\n            )\n          );\n        }\n\n        return this.getMetric({\n          metric,\n          labels: getLabels(metric),\n          atomic: true\n        });\n      })\n    );\n  }\n\n  /**\n   * @internal\n   *\n   * @param labels Name of metric properties to filter by\n   * @returns Observable of awareness metric events\n   */\n  public awareness(\n    label: AwarenessLabels,\n    ...otherLabels: AwarenessLabels[]\n  ): Observable<any> {\n    return this.getMetric({\n      metric: \"awareness\",\n      labels: label ? [label, ...otherLabels] : [],\n      atomic: false\n    });\n  }\n\n  /**\n   * The `raw` brainwaves parameter emits epochs of 25 samples.\n   *\n   * Example\n   * ```typescript\n   * notion.brainwaves(\"raw\").subscribe(brainwaves => {\n   *   console.log(brainwaves);\n   * });\n   * ```\n   *\n   * Raw Unfiltered - The `rawUnfiltered` brainwaves parameter emits epochs of 25 samples. \n\n   * Example\n   * ```typescript\n   * notion.brainwaves(\"rawUnfiltered\").subscribe(brainwaves => {\n   *   console.log(brainwaves);\n   * });\n   * ```\n   *\n   * Power By Band - The `powerByBand` brainwaves parameter emits epochs 4 times a second. Every frequency label (e.g. beta) contains an average power value per channel.\n   * \n   * Example\n   * ```typescript\n   * notion.brainwaves(\"powerByBand\").subscribe(brainwaves => {\n   *   console.log(brainwaves);\n   * });\n   * ```\n   *\n   * Power Spectral Density (PSD) - The `psd` brainwaves parameter emits epochs 4 times a second. Every frequency label (e.g. alpha) contains the computed FFT (Fast Fourier transform) value per channel (see the `psd` property), as well as the frequency ranges (see the `freqs` property).\n   * \n   * Example\n   * ```typescript\n   * notion.brainwaves(\"psd\").subscribe(brainwaves => {\n   *   console.log(brainwaves);\n   * });\n   * ```\n   *\n   * @param labels Name of metric properties to filter by\n   * @returns Observable of brainwaves metric events\n   */\n  public brainwaves(\n    label: BrainwavesLabel,\n    ...otherLabels: BrainwavesLabel[]\n  ): Observable<Epoch | PowerByBand | PSD> {\n    return this.getMetric({\n      metric: \"brainwaves\",\n      labels: label ? [label, ...otherLabels] : [],\n      atomic: false\n    });\n  }\n\n  /**\n   * Example\n   * ```typescript\n   * notion.calm().subscribe(calm => {\n   *   console.log(calm.probability);\n   * });\n   *\n   * // 0.45\n   * // 0.47\n   * // 0.53\n   * // 0.51\n   * // ...\n   * ```\n   *\n   * @returns Observable of calm events - awareness/calm alias\n   */\n  public calm(): Observable<Calm> {\n    return this.awareness(\"calm\");\n  }\n\n  /**\n   * Observes signal quality data where each property is the name\n   * of the channel and the value includes the standard deviation and\n   * a status set by the device\n   *\n   * ```typescript\n   * notion.signalQuality().subscribe(signalQuality => {\n   *   console.log(signalQuality);\n   * });\n   *\n   * // { FC6: { standardDeviation: 3.5, status: \"good\" }, C3: {...}, ... }\n   * ```\n   *\n   * @returns Observable of signalQuality metric events\n   */\n  public signalQuality(): Observable<SignalQuality> {\n    const metric = \"signalQuality\";\n    return this.getMetric({\n      metric,\n      labels: getLabels(metric),\n      atomic: true\n    });\n  }\n\n  /**\n   * @internal\n   * Proof of Concept for `emotion` - Not user facing yet\n   *\n   * @returns Observable of emotion metric events\n   */\n  public emotion(\n    label: string,\n    ...otherLabels: string[]\n  ): Observable<any> {\n    return this.getMetric({\n      metric: \"emotion\",\n      labels: label ? [label, ...otherLabels] : [],\n      atomic: false\n    });\n  }\n\n  /**\n   * Observes last state of `settings` and all subsequent `settings` changes\n   *\n   * ```typescript\n   * notion.settings().subscribe(settings => {\n   *   console.log(settings.lsl);\n   * });\n   *\n   * // true\n   * // ...\n   * ```\n   *\n   * @returns Observable of `settings` metric events\n   */\n  public settings(): Observable<Settings> {\n    return this.api.observeNamespace(\"settings\");\n  }\n\n  /**\n   * Example\n   * ```typescript\n   * notion.focus().subscribe(focus => {\n   *   console.log(focus.probability);\n   * });\n   *\n   * // 0.56\n   * // 0.46\n   * // 0.31\n   * // 0.39\n   * // ...\n   * ```\n   *\n   * @returns Observable of focus events - awareness/focus alias\n   */\n  public focus(): Observable<Focus> {\n    return this.awareness(\"focus\");\n  }\n\n  /**\n   * @param labels Name of metric properties to filter by\n   * @returns Observable of kinesis metric events\n   */\n  public kinesis(\n    label: string,\n    ...otherLabels: string[]\n  ): Observable<Kinesis> {\n    return this.getMetric({\n      metric: \"kinesis\",\n      labels: label ? [label, ...otherLabels] : [],\n      atomic: false\n    });\n  }\n\n  /**\n   * @param labels Name of metric properties to filter by\n   * @returns Observable of predictions metric events\n   */\n  public predictions(\n    label: string,\n    ...otherLabels: string[]\n  ): Observable<any> {\n    return this.getMetric({\n      metric: \"predictions\",\n      labels: label ? [label, ...otherLabels] : [],\n      atomic: false\n    });\n  }\n\n  /**\n   * Observes last state of `status` and all subsequent `status` changes\n   *\n   * ```typescript\n   * notion.status().subscribe(status => {\n   *   console.log(status.state);\n   * });\n   *\n   * // \"online\"\n   * // ...\n   * ```\n   *\n   * @returns Observable of `status` metric events\n   */\n  public status(): Observable<DeviceStatus> {\n    return this.api.status();\n  }\n\n  /**\n   * @internal\n   * Not user facing yet\n   *\n   * Changes device settings programmatically. These settings can be\n   * also changed from the developer console under device settings.\n   *\n   * Available settings [[ChangeSettings]]\n   *\n   * Example\n   * ```typescript\n   * notion.changeSettings({\n   *   lsl: true\n   * });\n   * ```\n   */\n  public changeSettings(settings: ChangeSettings): Promise<void> {\n    if (!this.api.didSelectDevice()) {\n      return Promise.reject(errors.mustSelectDevice);\n    }\n\n    return this.api.changeSettings(settings);\n  }\n\n  /**\n   *\n   * ```typescript\n   * notion.training.record({\n   *   metric: \"kinesis\",\n   *   label: \"push\"\n   * });\n   *\n   * notion.training.stop({\n   *   metric: \"kinesis\",\n   *   label: \"push\"\n   * });\n   * ```\n   *\n   * @returns Training methods\n   */\n  public get training(): Training {\n    return {\n      /**\n       * Records a training for a metric/label pair\n       * @category Training\n       */\n      record: (training) => {\n        if (!this.api.didSelectDevice()) {\n          throw errors.mustSelectDevice;\n        }\n\n        const userId =\n          this.api.user && \"uid\" in this.api.user\n            ? this.api.user.uid\n            : null;\n        const message = {\n          fit: false,\n          baseline: false,\n          timestamp: this.api.timestamp,\n          ...training,\n          userId\n        };\n        this.api.actions.dispatch({\n          command: \"training\",\n          action: \"record\",\n          message\n        });\n      },\n      /**\n       * Stops the training for a metric/label pair\n       * @category Training\n       */\n      stop: (training) => {\n        if (!this.api.didSelectDevice()) {\n          throw errors.mustSelectDevice;\n        }\n\n        this.api.actions.dispatch({\n          command: \"training\",\n          action: \"stop\",\n          message: {\n            ...training\n          }\n        });\n      },\n      /**\n       * Stops all trainings\n       * @category Training\n       */\n      stopAll: () => {\n        if (!this.api.didSelectDevice()) {\n          throw errors.mustSelectDevice;\n        }\n\n        this.api.actions.dispatch({\n          command: \"training\",\n          action: \"stopAll\",\n          message: {}\n        });\n      }\n    };\n  }\n\n  /**\n   * @internal\n   * Proof of Concept for disconnecting db\n   */\n  public goOffline(): void {\n    this.api.goOffline();\n  }\n\n  /**\n   * @internal\n   * Proof of Concept for resuming db connection\n   */\n  public goOnline(): void {\n    this.api.goOnline();\n  }\n\n  /**\n   * @internal\n   * Not user facing yet\n   *\n   * Creates user account and automatically signs in with same credentials\n   *\n   * @param emailAndPasswordObject\n   * @returns user credential\n   */\n  public createAccount(credentials: EmailAndPassword) {\n    return this.api.createAccount(credentials);\n  }\n\n  /**\n   * @internal\n   * Not user facing yet\n   *\n   * Removes all devices from an account and then deletes the account\n   */\n  public deleteAccount() {\n    return this.api.deleteAccount();\n  }\n\n  /**\n   * @internal\n   * Not user facing yet\n   *\n   * Creates custom token (JWT) to use to login with `{ customToken }`.\n   *\n   * @returns custom token\n   */\n  public createCustomToken(): Promise<CustomToken> {\n    return this.api.createCustomToken();\n  }\n\n  /**\n   * @internal\n   * Not user facing yet\n   *\n   * Gets the offset between the device's clock and the client's clock\n   * Requires option.timesync to be true\n   *\n   * @returns timesyncOffset\n   */\n  public getTimesyncOffset(): number {\n    if (!this.options.timesync) {\n      console.warn(\n        `getTimesyncOffset() requires options.timesync to be true.`\n      );\n    }\n\n    return this.options.timesync ? this.api.getTimesyncOffset() : 0;\n  }\n\n  /**\n   * @internal\n   * Proof of Concept for Skills - Not user facing yet\n   *\n   * Accesses a skill by Bundle ID. Additionally, allows to observe\n   * and push skill metrics\n   *\n   * @param bundleId Bundle ID of skill\n   * @returns Skill instance\n   */\n  public async skill(bundleId: string): Promise<SkillInstance> {\n    if (!this.api.didSelectDevice()) {\n      return Promise.reject(errors.mustSelectDevice);\n    }\n\n    const skillData = await this.api.skills.get(bundleId);\n\n    if (skillData === null) {\n      return Promise.reject(\n        new Error(\n          `Access denied for: ${bundleId}. Make sure the skill is installed.`\n        )\n      );\n    }\n\n    return {\n      metric: (label: string) => {\n        const metricName = `skill~${skillData.id}~${label}`;\n        const subscription = new Observable((observer) => {\n          const subscription: Subscription = this.api.metrics.subscribe(\n            {\n              metric: metricName,\n              labels: [label],\n              atomic: true\n            }\n          );\n\n          const listener = this.api.metrics.on(\n            subscription,\n            (...data: any) => {\n              observer.next(...data);\n            }\n          );\n\n          return () => {\n            this.api.metrics.unsubscribe(subscription, listener);\n          };\n        }).pipe(map((metric) => metric[label]));\n\n        Object.defineProperty(subscription, \"next\", {\n          value: (metricValue: { [label: string]: any }): void => {\n            this.api.metrics.next(metricName, {\n              [label]: metricValue\n            });\n          }\n        });\n\n        return subscription;\n      }\n    };\n  }\n}\n","import { Notion } from \"../Notion\";\nimport { NotionOptions } from \"../types/options\";\nimport { Skill, SkillInstance } from \"../types/skill\";\n\nexport type NotionOnDevice = Omit<Notion, \"skill\">;\n\nexport interface OnDeviceOptions extends NotionOptions {\n  onDeviceSocketUrl: string;\n  skill: Skill;\n}\n\n/**\n * @internal\n */\nexport async function createNotionOnDevice(\n  options: OnDeviceOptions\n): Promise<[NotionOnDevice, SkillInstance]> {\n  const notion = new Notion(options);\n  const skill = {\n    ...(await notion.skill(options.skill.bundleId)),\n    props: \"props\" in options.skill ? options.skill.props : {}\n  };\n  delete notion.skill;\n  return [notion, skill];\n}\n","import {\n  createNotionOnDevice,\n  OnDeviceOptions,\n  NotionOnDevice\n} from \"./NotionOnDevice\";\nimport { SkillInstance, SkillSubscription } from \"../types/skill\";\n\ntype SkillApp = (\n  notion: NotionOnDevice,\n  skill: SkillInstance\n) => () => Promise<void>;\n\nexport function createSkill(app: SkillApp) {\n  return {\n    subscribe: async (\n      options: OnDeviceOptions\n    ): Promise<SkillSubscription> => {\n      const [notion, skill] = await createNotionOnDevice({\n        ...options\n      });\n\n      await notion\n        .enableLocalMode(true)\n        .catch((error) => console.error(error.message));\n\n      const teardown = app(notion, skill);\n\n      return {\n        unsubscribe: async () => {\n          await notion.disconnect();\n\n          if (teardown && \"then\" in teardown) {\n            const cleanUp: any = await teardown;\n            if (typeof cleanUp === \"function\") {\n              cleanUp();\n            }\n          }\n\n          if (typeof teardown === \"function\" && \"then\" in teardown()) {\n            return await teardown();\n          }\n\n          if (typeof teardown === \"function\") {\n            return teardown();\n          }\n\n          return teardown;\n        }\n      };\n    }\n  };\n}\n","export * from \"./createSkill\";\nexport * from \"./NotionOnDevice\";\n","export * from \"./Notion\";\nexport * from \"./skills\";\n"]}